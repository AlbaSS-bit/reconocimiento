<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Página de ejemplo - plantilla básica HTML" />
    <title>Título de la página</title>

    <!-- Hoja de estilos opcional -->
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <h1>Encabezado principal</h1>
      <nav>
        <!-- Navegación principal -->
      </nav>
    </header>

    <main>
      <section>
        <h2>Sección</h2>
        <p>Contenido de ejemplo.</p>
      </section>

      <section id="camera-section">
        <h2>Reconocimiento en vídeo</h2>
        <!-- La cámara se iniciará automáticamente al abrir la página en el móvil -->

  <!-- Elemento de vídeo donde veremos la cámara -->
        <!--
          Atributos importantes:
          - muted: permite autoplay en muchos navegadores móviles sin interacción del usuario
          - playsinline: evita que Safari/iOS abra el vídeo en pantalla completa
          - disablePictureInPicture: desactiva Picture-in-Picture en navegadores que lo soportan
          - aria-label: accesibilidad para lectores de pantalla
        -->
        <video
          id="webcam"
          autoplay
          muted
          playsinline
          disablePictureInPicture
          width="640"
          height="480"
          aria-label="Vista previa de la cámara"
          style="max-width:100%;height:auto;"
        ></video>

        <!-- Contenedor para imprimir los resultados del modelo -->
        <div id="results" aria-live="polite">
          <h3>Resultados</h3>
          <ul id="predictions"></ul>
        </div>
      </section>
    </main>

    <footer>
      <p>© 2026 Tu nombre o empresa</p>
    </footer>

    <!-- Scripts de TensorFlow.js y modelo MobileNet (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>

    <!-- Script opcional de la aplicación -->
     <script>
        // Código para iniciar y detener la cámara trasera en el elemento <video id="webcam">.
// Nota: getUserMedia requiere un contexto seguro (https) o localhost en la mayoría de navegadores.

let currentStream = null;
let model = null;
let predictInterval = null;
const PREDICTION_INTERVAL = 500; // ms

const videoEl = document.getElementById('webcam');
const resultsEl = document.getElementById('results');
const predictionsList = document.getElementById('predictions');


async function startCamera() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('getUserMedia no está disponible en este navegador. Usa un navegador moderno.');
    return;
  }

  try {
    // Intento preferente: pedir la cámara trasera usando facingMode ideal
    const constraints = { video: { facingMode: { ideal: 'environment' } }, audio: false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    attachStream(stream);
    return;
  } catch (err) {
    console.warn('No se pudo abrir con facingMode, intentando fallback por deviceId:', err);
  }

  // Fallback: enumerar dispositivos y tratar de seleccionar uno que parezca trasero
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === 'videoinput');

    if (videoDevices.length === 0) {
      throw new Error('No se encontraron dispositivos de vídeo.');
    }

    // Buscar palabras clave en la etiqueta del dispositivo para identificar la trasera
    const backRegex = /back|rear|environment|trasera|posterior/i;
    let chosen = videoDevices.find(d => backRegex.test(d.label));

    // Si no hay labels (sin permiso) o no se encontró, tomar el último dispositivo como heurística
    if (!chosen) {
      chosen = videoDevices[videoDevices.length - 1];
    }

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: chosen.deviceId } },
      audio: false,
    });

    attachStream(stream);
  } catch (err) {
    console.error('No se pudo acceder a la cámara:', err);
    alert('Error al acceder a la cámara: ' + (err && err.message ? err.message : err));
  }
}

function attachStream(stream) {
  // Detener stream anterior si existía
  if (currentStream) stopCamera();

  currentStream = stream;
  // Mostrar el stream en el elemento video
  try {
    videoEl.srcObject = stream;
    // Asegurar que el vídeo está silenciado para permitir autoplay en móviles
    videoEl.muted = true;
    // Algunos navegadores requieren play() explícito
    videoEl.play().catch(e => {
      // Ignorar si play falla por políticas de autoplay; el usuario puede interactuar
      console.warn('video.play() rechazado:', e);
    });
    // Cargar modelo si no está cargado y comenzar predicciones
    startPredictions();
  } catch (err) {
    console.error('Error al asignar srcObject:', err);
  }
}

function stopCamera() {
  if (!currentStream) return;

  // Detener todas las pistas
  currentStream.getTracks().forEach(track => track.stop());
  currentStream = null;
  videoEl.pause();
  try {
    videoEl.srcObject = null;
  } catch (e) {
    // fallback: asignar empty src
    videoEl.removeAttribute('src');
  }
  // Detener predicciones si están corriendo
  stopPredictions();
}

// Eventos de los botones
// Nota: los botones han sido retirados; la cámara se inicia automáticamente.

// Si la pestaña se oculta, opcionalmente detener la cámara para ahorrar batería
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // no detener automáticamente si se desea mantener la sesión; aquí lo hacemos
    if (currentStream) stopCamera();
  }
});

// Iniciar la cámara automáticamente al cargar la página
document.addEventListener('DOMContentLoaded', () => {
  const h3 = resultsEl.querySelector('h3');
  if (h3) h3.textContent = 'Inicializando cámara y modelo...';
  startCamera();
});

// Exportar para otros módulos (si se desea usar desde consola)
window.startCamera = startCamera;
window.stopCamera = stopCamera;

// ----- MobileNet / TensorFlow.js integration -----
async function loadModel() {
  if (model) return model;
  try {
    resultsEl.querySelector('h3').textContent = 'Cargando modelo...';
    // mobilenet está disponible por el script incluido en HTML: window.mobilenet
    model = await window.mobilenet.load();
    resultsEl.querySelector('h3').textContent = 'Modelo cargado';
    return model;
  } catch (err) {
    console.error('Error cargando MobileNet:', err);
    resultsEl.querySelector('h3').textContent = 'Error cargando modelo';
    throw err;
  }
}

function updatePredictions(preds) {
  // Limpiar lista
  while (predictionsList.firstChild) predictionsList.removeChild(predictionsList.firstChild);
  if (!preds || preds.length === 0) {
    const li = document.createElement('li');
    li.textContent = 'No hay predicciones';
    predictionsList.appendChild(li);
    return;
  }

  preds.forEach(p => {
    const li = document.createElement('li');
    li.textContent = `${p.className} — ${(p.probability * 100).toFixed(2)}%`;
    predictionsList.appendChild(li);
  });
}

async function startPredictions() {
  if (!currentStream) return;
  // Cargar modelo si no está
  try {
    await loadModel();
  } catch (err) {
    console.error('No se puede iniciar predicciones sin el modelo');
    return;
  }

  // Evitar múltiples intervalos
  if (predictInterval) return;

  // Ejecutar una predicción inmediata y luego en intervalo
  const runOnce = async () => {
    try {
      const preds = await model.classify(videoEl);
      updatePredictions(preds);
    } catch (err) {
      console.error('Error en clasificación:', err);
    }
  };

  await runOnce();
  predictInterval = setInterval(runOnce, PREDICTION_INTERVAL);
}

function stopPredictions() {
  if (predictInterval) {
    clearInterval(predictInterval);
    predictInterval = null;
  }
  // Limpiar predicciones
  updatePredictions([]);
}
     </script>
  </body>
</html>
